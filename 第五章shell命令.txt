第五章shell命令
●一、Shell 中常用的 Linux 命令
●echo   "hello world"           将文字内容打印在屏幕上   
●wc  -l  filename               计算文件行数
●wc -w filename               计算文件中的单词数
●wc  -c filename                计算文件中的字符数   
●cp    被拷贝的文件名或路径   拷贝另一个位置什么路径和文件名          文件拷贝
●mv oldname newname          重命名文件或移动文件      
●rm    file          删除文件     rm  -rf   文件名或路径  递给删除不显示错误信息
●grep 'pattern' file          在文件内搜索字符串，比如 grep 'searchstring' file.txt
●cat file.txt          输出文件内容到标准输出设备（屏幕）上
●file    somefile          得到文件类型         
●find           搜索文件
●根据文件名搜索  find   /home     -name      "*.txt"      最好指定查找路径，避免使用根路径，如果使用通配符查询名字最好使用引号引起来
●* 匹配任意内容  
●?匹配任意一个字符 
●[]匹配任意一个中括号的字符
● find   /home     -iname      "*.txt"     加 i  不区分大小写
●who 显示终端登录信息   -a   显示所有信息    -q  显示当前登录人和登录数量
●输入和输出重定向

●例
●who -a > test.txt     将终端登录信息内容输出(写入)到文件                   echo "" >  test.txt   覆盖test.txt中的内容，可以做清空使用
●cat < test.txt             将文件内容读取出来，用cat显示
●cat a.js >>b.js          将文件a中的内容，追加到b中（注:两个文件不能是同一个文件）
●合并

●例
●可能会发生错误的指令  >&   error.txt      可以把可能发生错误的指令，在发生错误时的错误信息记录到文件（比如切换不存在的用户）
●二、进程优先级
●优先级取值范围为（-20,19），Linux 提供的优先级的范围为 -20 ～ 19，启动一个进程时，默认的优先级为 0，其中 -20 的优先级为最大或者说最高
●ps  静态任务管理器
●top  动态任务管理器
●ps -elf   带有优先级的进程
●修改优先级（进程优先级是为了占用cpu时间设定的）
●1，top命令。输入r，然后根据提示输入进程ID，再输入优先级数值。
●2，renice命令。renice -n 2 -p 3432。-n，后面是优先级的值；-p，是进程号。
●3.  nice 查看当前优先级默认值     nice -n 10 bash  将将要执行的bash优先级设置成10
●三、挂起进程
●执行死循环脚本

●nohup /bin/bash go.sh &   挂起进程并执行
●CentOS进程管理即前后台查看、运行、挂起、终止任务命令
●一、&
●加在一个命令的最后，可以把这个命令放到后台执行，如
●watch -n 10 sh test.sh & #每10s在后台执行一次test.sh脚本
●二、ctrl + z
●前台进程的挂起。可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行。
●后台进程的挂起：
●在redhat中，可通过执行命令kill -stop PID，将进程挂起；
●当要重新执行当前被挂起的任务时，通过bg  num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg  num即可；
●三、jobs
●查看当前有多少在后台运行的命令
●jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；
●注意：jobs只能查看当前xshell连接服务器窗口创建的任务。如果你并没有用nohup启动后台任务，那么就没有显示。
●四、fg
●将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用fg jobnumber将选中的命令调出。jobnumber是通过jobs命令查到的后台正在执行的命令的序号（是命令编号，不是进程号pid）
●五、bg
●将一个在后台暂停的命令，变成在后台继续执行，终端还能继续接受命令。如果后台中有多个命令，可以用bg  jobnumber将选中的命令调出。 jobnumber是通过jobs命令查到的后台正在执行的命令的序号（是命令编号，不是进程号pid）
●理解概念：当前任务
●如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]” 的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务
●六、kill
●后台进程的终止：
●法子1：通过jobs命令查看job号（假设为num），然后执行kill  num
●法子2：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill -9 pid
●前台进程的终止：Ctrl+c
●七、nohup
●如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&做不到），这时候需要nohup。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）
●ps -aux | grep “test.sh” #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分
●ctrl + z 挂起进程   暂停
●ctrl  + c 停止进程   退出
●kill -stop 后台任务号   暂停任务
●jobs -l  带有PID的任务
●四、工作调度
●Linux 有两种工作调度的方式：例行性的，就是每隔一定的周期执行；突发性的，就是仅仅执行一次
●at：是个可以处理仅执行一次就结束调度的指令。要执行 at 时，必须要有 atd 服务的支持
●crontab：这个指令所设置的工作将会一直循环执行，可循环的时间为分钟、小时、每周、每月或每年等
●要使用单一工作调度时，Linux 系统上面必须要有负责这个调度的服务，那就是 atd 服务
●systemctl  status atd   查看atd状态
●一分钟后执行
●at   now +1 minutes 回车   输入 一分钟后的任务    echo  "hello world" >  a.txt    回车输入  结束符  <EOT>
●at  17:30 回车  输入到时的任务   ls \ > 2.txt  回车输入结束符  <EOT>
●  使用atq 查看待处理的作业
●atm   任务号   使用 atrm 删除无用的作业
●crontab 是用来让使用者在固定时间或固定间隔执行程序    计划任务每个用户设定的都是独立的
●  -e    	  编辑 crontab 的工作内容
●  -r          移除所有的  crontab 的工作内容，若仅要移除一项，请用 -e 去编辑
●  -l           查阅  crontab 的工作内容
●查看其他人的计划任务         crontab  -l  -u 用户名
●修改其他人的计划任务         crontab -e   -u  用户名
●时程表的格式：f1 f2 f3 f4 f5 program
●f1表示分钟，f2表示小时，f3表示一个月份中的第几日，f4表示月份，f5表示一个星期中的第几天。program表示要执行的程序。
●当f1 为* 时，表示每分钟都要执行 program；当f2 为* 时，表示每小时都要执行程序。其余以此类推。
●当f1 为a-b 时，表示从第a 分钟到第b 分钟这段时间内要执行；当f2 为a-b 时，表示从第a 小时到第b小时都要执行。其余以此类推。
●当f1 为*/n 时，表示每n 分钟时间间隔执行一次；当f2 为*/n 时，表示每n 小时时间间隔执行一次。其余以此类推。
●当f1 为a、b、c……时，表示第a、b、c……分钟要执行；当f2 为a、b、c……时，表示第a、b、c……个小时要执行。其余以此类推。
●例（查看系统时间:  timedatectl    或者  date ）
●每月每天每小时的第 0 分钟执行一次 /bin/ls                                                                 0* * * * /bin/ls
●每天的早上6 点到12 点中，每隔3 小时执行一次                                                    0 6-12/3 * *  *   /usr/bin/app.sh
●每个月的周一到周五下午5点整，发送邮件给一个邮箱                                   0  17  *   *  1-5   mail  -s   "hi"   abc@domain.name
●每月每天的 0 点 20 分、2 点 20 分、4 点 20 分……执行 echo "haha"                       20  0-23/2   *   *   *   echo "haha"